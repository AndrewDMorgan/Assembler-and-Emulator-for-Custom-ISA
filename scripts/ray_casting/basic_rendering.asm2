; basic rendering things (like columns and stuff; maybe textures)

; gets the textures color, and shoves it into rdc
; uses %acc, returns via rdc
.get_textured_pixel_for_column:
    ; rda is the current height
    ; rdk is the size
    ; (16/size) * current_height
    ; (16<<10  / size) * current_height  >> 10
    ; use fixed point ig? A max of 16 is all that's needed, so maybe 10 shifts for good precision?

    ; computing 16/size
    ldial $16384   ; 16 << 10
    ldrar %rdk
    div            ; 16<<10 / size
    movreg %acc
    ldral %acc
    ldrar %rda
    mult           ; (...) * index
    movreg %acc    ; current index

    ; translating back to integer
    ldral %acc
    ldiar $10
    right          ; (...) * ...  >> 10 (final step)
    movreg %acc

    ; finding the location relative to the texture coord
    ldral %acc
    ldiar $16
    mult
    movreg %acc
    ldral %acc
    ldrar %rdi  ; the pointer to the texture
    add
    movreg %acc
    ldrp [%acc] %rdc

    ; no clue why using ret was causing sooooo many issues....
    jmp #get_textured_pixel_for_column_return


; renderings a column from the middle of the screen with a given size
; uses rdl, rdk, rdj, rda, rdb, acc, rdi, rdc
.render_casted_column:
    ; the first value in the stack is the x position
    ; the second value in the stack is the size
    ; the third value in the stack is the offset (first bit represents the sign -> +/-)
    ; stack: [....x, size, offset]
    pop %acc       ; saving the return address
    pop %rdl       ; x position (x-pixel coord)
    pop %rdk       ; size
    pop %rda       ; offset -- will be an input into the signed addition function
    pop %rdi       ; a pointer to the start of a vertical slice of a 16x16 texture
    psh %acc       ; restoring the return address
    ldi %rdb $40   ; the generic offset (center of screen
    call #signed_addition  ; %rda will contain the updated value
    ldral %rdk
    ldiar $1
    right          ; halving the value
    movreg %acc
    ldral %rda
    ldrar %acc
    sub            ; column_center(rda) - size(rdk) / 2(>>1)
    movreg %rdj    ; the actual y coord to start at (incase of half blocks or something ig)
    jnc #non_overflowing_y_for_rendering_casted_columns

    clr %rdj       ; basic bounds check for safety (incase the player is right up against a wall or something)
    ; adjusting the total size
    ldrar %rda
    ldral %acc
    sub
    movreg %acc
    ldral %rdk
    ldrar %acc
    sub
    movreg %rdk    ; should now be correctly sized

  .non_overflowing_y_for_rendering_casted_columns:
    ; second bounds check for height
    ; if size + starting y > 127 set size to 127 - starting_y
    ldral %rdk
    ldrar %rdj
    add
    movreg %acc
    ldral %acc
    ldiar $127
    cmpg
    jnz #non_bounds_exceeding_y_for_rendering_casted_columns

    ; getting the valid position
    ldial $79
    ldrar %rdj
    sub
    movreg %rdk    ; this should now be correct and safe (a small overflow is fine sense there's a small buffer built in to ensure no memory collisions)

  .non_bounds_exceeding_y_for_rendering_casted_columns:    ; long names to ensure no collisions

    ldral %rdj
    ldiar $128
    mult           ; turning it to a pixel coord
    movreg %rdj

    ; starting the loop to actually render the column
    clr %rda       ; stores the iteration count (if equal to size, stop the loop)
    grab #0 %rdb   ; the screen pointer
    ldral %rdb
    ldrar %rdl
    add            ; getting the offset-ed position
    movreg %rdb
    ldral %rdb
    ldrar %rdj
    add
    movreg %rdb    ; offsetting based on the y position
    ; offsetting for the y position start
    .casted_column_rendering_loop:
        jmp #get_textured_pixel_for_column  ; gets the pixel color
      .get_textured_pixel_for_column_return:
        strp [%rdb] %rdc

        ; checking the bounds of the loop (and increasing the iteration count)
        ldral %rda
        inc              ; updating the iteration count
        movreg %rda

        ldral %rdb
        ldiar $128
        add              ; moving down one pixel
        movreg %rdb

        ldral %rda
        ldrar %rdk
        cmpeq
        jnz #casted_column_rendering_loop
    ret

